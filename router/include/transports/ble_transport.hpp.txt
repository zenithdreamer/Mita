#ifndef MITA_ROUTER_BLE_TRANSPORT_HPP
#define MITA_ROUTER_BLE_TRANSPORT_HPP

#include "core/transport_interface.hpp"
#include "protocol/protocol.hpp"
#include <thread>
#include <atomic>
#include <map>
#include <mutex>
#include <memory>
#include <vector>
#include <set>
#include <condition_variable>

#include "transports/ble_backend.hpp"

namespace mita
{
    namespace core
    {
        class RouterConfig;
        class Logger;
    }
    namespace services
    {
        class RoutingService;
        class DeviceManagementService;
        class StatisticsService;
    }
}

namespace mita
{
    namespace transports
    {

        /**
         * BLE device handler for individual device connections
         */
        class BLEDeviceHandler
        {
        public:
            BLEDeviceHandler(IBLEBackend *backend,
                             const std::string &device_address,
                             const core::RouterConfig &config,
                             services::RoutingService &routing_service,
                             services::DeviceManagementService &device_management,
                             services::StatisticsService &statistics_service);
            ~BLEDeviceHandler();

            bool connect_and_setup();
            void disconnect();
            bool is_connected() const { return connected_; }
            bool is_authenticated() const { return authenticated_; }
            const std::string &get_device_id() const { return device_id_; }
            uint16_t get_assigned_address() const { return assigned_address_; }

            // Packet transmission
            bool send_packet(const protocol::ProtocolPacket &packet);

            // Exposed for backend notification callback
            void notify_from_backend(const std::vector<uint8_t> &data) { handle_notification(data); }

        private:
            void handle_notification(const std::vector<uint8_t> &data);
            void handle_handshake_packet(const protocol::ProtocolPacket &packet);
            void handle_data_packet(const protocol::ProtocolPacket &packet);

            // Configuration and services
            const core::RouterConfig &config_;
            services::RoutingService &routing_service_;
            services::DeviceManagementService &device_management_;
            services::StatisticsService &statistics_service_;

            // Device information
            std::string device_address_;
            std::string device_id_;
            uint16_t assigned_address_;

            // Connection state
            bool connected_;
            bool authenticated_;
            std::atomic<bool> running_;

            // Authentication
            std::unique_ptr<protocol::HandshakeManager> handshake_manager_;
            std::shared_ptr<protocol::PacketCrypto> session_crypto_;

            // Backend (non-owning)
            IBLEBackend *backend_;

            std::shared_ptr<core::Logger> logger_;
        };

        /**
         * BLE transport implementation using BlueZ D-Bus APIs
         */
        class BLETransport : public core::BaseTransport
        {
        public:
            BLETransport(const core::RouterConfig &config,
                         services::RoutingService &routing_service,
                         services::DeviceManagementService &device_management,
                         services::StatisticsService &statistics_service);
            ~BLETransport();

            // TransportInterface implementation
            bool start() override;
            void stop() override;
            core::TransportType get_type() const override { return core::TransportType::BLE; }
            bool send_packet(const std::string &device_id, const protocol::ProtocolPacket &packet) override;
            int broadcast_packet(const protocol::ProtocolPacket &packet) override;
            std::string get_connection_info() const override;

        private:
            void scan_loop();
            void handle_device_discovery();
            void handle_device_found(const std::string &device_address, const std::string &device_name);
            bool connect_to_device(const std::string &device_address, std::unique_ptr<IBLEBackend> &backend);
            void cleanup_disconnected_devices();
            BLEDeviceHandler *find_device_handler(const std::string &device_id);
            std::string device_address_from_id(const std::string &device_id) const;
            bool device_has_service(const std::string &device_address, const std::string &service_uuid);

            // Adapter / discovery management
            bool initialize_adapter();
            bool start_discovery();
            void stop_discovery();

            // Backend abstraction when using SimpleBluez
            std::unique_ptr<IBLEBackend> backend_;

            // Device management
            mutable std::mutex devices_mutex_;
            std::map<std::string, std::unique_ptr<BLEDeviceHandler>> device_handlers_;
            std::set<std::string> seen_devices_;

            // Threading
            std::unique_ptr<std::thread> scan_thread_;
            std::condition_variable scan_cv_;
            std::mutex scan_mutex_;

            std::shared_ptr<core::Logger> logger_;
        };

    } // namespace transports
} // namespace mita

#endif // MITA_ROUTER_BLE_TRANSPORT_HPP